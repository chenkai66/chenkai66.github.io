<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    R语言实战（三） |  言念君子
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-R语言实战（三）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  R语言实战（三）
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/17ce1303.html" class="article-date">
  <time datetime="2020-08-14T09:53:39.387Z" itemprop="datePublished">2020-08-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/R/">R</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">34 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>本次分享，我们将评述用于生成基本的描述性统计量和推断统计量的R函数。首先，我们将着眼于定量变量的位置和尺度的衡量方式。然后我们将学习生成类别型变量的频数表和列联表的方法（以及连带的卡方检验）。接下来，我们将考察连续型和有序型变量相关系数的多种形式。最后，我们将转而通过参数检验（t检验）和非参数检验（Mann-WhitneyU检验、Kruskal-Wallis检验）方法研究组间差异。</p>
<p>参考书籍：</p>
<blockquote>
<p>《R语言实战—第2版》————-Robert I.Kabacoff</p>
</blockquote>
<p><strong>本次内容：</strong></p>
<ol>
<li><strong>描述性统计分析</strong></li>
<li><strong>频数表和列联表</strong></li>
<li><strong>相关</strong></li>
<li><strong>t检验</strong></li>
<li><strong>组间差异的非参数检验</strong></li>
</ol>
<h1 id="1-描述性统计分析"><a href="#1-描述性统计分析" class="headerlink" title="1. 描述性统计分析"></a>1. 描述性统计分析</h1><p>我们将使用中Motor Trend杂志的车辆路试（mtcars）数据集。我们的关注焦点是每加仑汽油行驶英里数（mpg） 、马力（hp）和车重（wt）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(car)</span><br><span class="line">attach(mtcars)</span><br><span class="line">myvars &lt;- c(&quot;mpg&quot;,&quot;hp&quot;,&quot;wt&quot;)</span><br><span class="line">head(mtcars[myvars])</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-fd475d968ea368e2d950241e22eda92e_720w.jpg" alt="img"></p>
<p>我们将首先查看所有32种车型的描述性统计量，然后按照变速箱类型（am）和汽缸数（cyl）考察描述性统计量。变速箱类型是一个以0表示自动挡、1表示手动挡来编码的二分变量，而汽缸数可为4、5或6。</p>
<h2 id="1-1-使用summary-函数来获取描述性统计量"><a href="#1-1-使用summary-函数来获取描述性统计量" class="headerlink" title="1.1 使用summary()函数来获取描述性统计量"></a>1.1 使用summary()函数来获取描述性统计量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myvars &lt;- c(&quot;mpg&quot;,&quot;hp&quot;,&quot;wt&quot;)</span><br><span class="line">summary(mtcars[myvars])</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-579306ded6133d2c94a145c57c98a0f5_720w.jpg" alt="img"></p>
<p><strong>summary()函数提供了最小值、最大值、四分位数和数值型变量的均值，以及因子向量和逻辑型向量的频数统计。</strong></p>
<h2 id="1-2-通过sapply-计算描述性统计量"><a href="#1-2-通过sapply-计算描述性统计量" class="headerlink" title="1.2 通过sapply()计算描述性统计量"></a>1.2 通过sapply()计算描述性统计量</h2><p>sapply()函数，其使用格式为：</p>
<p>sapply(x, FUN, options)</p>
<p>其中的x是你的数据框（或矩阵），FUN为一个任意的函数。如果指定了options，它们将被传递给FUN。你可以在这里插入的典型函数有mean()、sd()、var()、min()、max()、median()、length()、 range()和quantile()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mystats &lt;- function(x,na.omit&#x3D;FALSE)&#123;</span><br><span class="line">  if(na.omit)&#123;x &lt;- x[!is.na(x)]&#125;</span><br><span class="line">  m &lt;- mean(x)</span><br><span class="line">  n &lt;- length(x)</span><br><span class="line">  s &lt;- sd(x)</span><br><span class="line">  skew &lt;- sum((x-m)^3&#x2F;s^3)&#x2F;n</span><br><span class="line">  kurt &lt;- sum((x-m)^4&#x2F;s^4)&#x2F;n-3</span><br><span class="line">  return(c(n&#x3D;n,mean&#x3D;m,stdev&#x3D;s,skew&#x3D;skew,kurtosis&#x3D;kurt))</span><br><span class="line">&#125;</span><br><span class="line">myvars &lt;- c(&quot;mpg&quot;,&quot;hp&quot;,&quot;wt&quot;)</span><br><span class="line">sapply(mtcars[myvars], mystats)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-d020b9a1a2901cee219233013eaaeac1_720w.jpg" alt="img"></p>
<p>对于样本中的车型， 每加仑汽油行驶英里数的平均值为20.1，标准差为6.0。分布呈现右偏（偏度+0.61），并且较正态分布稍平（峰度–0.37）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library(RColorBrewer) </span><br><span class="line">mycolors &lt;- brewer.pal(8, &quot;Set1&quot;) </span><br><span class="line">hist(mtcars$mpg,col &#x3D; mycolors[2],xlab &#x3D; &quot;mpg&quot;,breaks &#x3D; 15,freq &#x3D; FALSE)</span><br><span class="line">lines(density(mtcars$mpg), col&#x3D;mycolors[1], lwd&#x3D;2) </span><br><span class="line">abline(v &#x3D; mean(mtcars$mpg),lty&#x3D;2,col&#x3D;mycolors[3])</span><br><span class="line">text(mean(mtcars$mpg)-2.5,0.01,&quot;mean(mpg)&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-a5f7b6a6b1f751e142dc31d8eacf4028_720w.jpg" alt="img"></p>
<h2 id="1-3-pastecs包中的stat-desc-函数计算描述性统计量"><a href="#1-3-pastecs包中的stat-desc-函数计算描述性统计量" class="headerlink" title="1.3 pastecs包中的stat.desc()函数计算描述性统计量"></a>1.3 pastecs包中的stat.desc()函数计算描述性统计量</h2><p>pastecs包中有一个名为stat.desc()的函数， 它可以计算种类繁多的描述性统计量。 使用格式为：</p>
<p>stat.desc(x, basic=TRUE, desc=TRUE, norm=FALSE, p=0.95)</p>
<p>其中的x是一个数据框或时间序列。若basic=TRUE（默认值），则计算其中所有值、空值、缺失值的数量，以及最小值、最大值、值域，还有总和。若desc=TRUE（同样也是默认值），则计算中位数、平均数、平均数的标准误、平均数置信度为95%的置信区间、方差、标准差以及变异系数。最后，若norm=TRUE（不是默认的），则返回正态分布统计量，包括偏度和峰度（以及它们的统计显著程度）和Shapiro-Wilk正态检验结果。这里使用了p值来计算平均数的置信区间（默认置信度为0.95） 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(pastecs)</span><br><span class="line">myvars &lt;- c(&quot;mpg&quot;,&quot;hp&quot;,&quot;wt&quot;)</span><br><span class="line">stat.desc(mtcars[myvars],norm&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-80fc3b04c7cf18fb3e76f457e5b4a625_720w.jpg" alt="img"></p>
<h2 id="1-4-使用aggregate-分组获取描述性统计量"><a href="#1-4-使用aggregate-分组获取描述性统计量" class="headerlink" title="1.4 使用aggregate()分组获取描述性统计量"></a>1.4 使用aggregate()分组获取描述性统计量</h2><p>在比较多组个体或观测时，关注的焦点经常是各组的描述性统计信息，而不是样本整体的描述性统计信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myvars &lt;- c(&quot;mpg&quot;,&quot;hp&quot;,&quot;wt&quot;)</span><br><span class="line">aggregate(mtcars[myvars],by&#x3D;list(am&#x3D;mtcars$am),mean)</span><br><span class="line">aggregate(mtcars[myvars],by&#x3D;list(am&#x3D;mtcars$am),sd)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-87aa841532fd1c70e91b8f856a643afc_720w.jpg" alt="img"></p>
<p>注意list(am=mtcars$am)的使用。如果使用的是list(mtcars$am)，则am列将被标注为Group.1而不是am。你使用这个赋值指定了一个更有帮助的列标签。如果有多个分组变量，可以使用by=list(name1=groupvar1, name2=groupvar2, … , nameN=groupvarN)这样的语句。<strong>遗憾的是，aggregate()仅允许在每次调用中使用平均数、标准差这样的单返回值函数。它无法一次返回若干个统计量。</strong></p>
<h2 id="1-5-使用by-分组计算描述性统计量"><a href="#1-5-使用by-分组计算描述性统计量" class="headerlink" title="1.5 使用by()分组计算描述性统计量"></a>1.5 使用by()分组计算描述性统计量</h2><p>使用by()函数。格式为:by(data, INDICES, FUN)</p>
<p>其中data是一个数据框或矩阵，INDICES是一个因子或因子组成的列表，定义了分组，FUN是任意函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dstats &lt;- function(x)sapply(x, mystats)</span><br><span class="line">myvars &lt;- c(&quot;mpg&quot;,&quot;hp&quot;,&quot;wt&quot;)</span><br><span class="line">by(mtcars[myvars],mtcars$am,dstats)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-4acbddeb930ae4a6aa2380440873cf05_720w.jpg" alt="img"></p>
<p>dstats()调用了mystats()函数，将其应用于数据框的每一栏中。再通过by()函数则可得到am中每一水平的概括统计量。</p>
<h1 id="2-频数表和列联表"><a href="#2-频数表和列联表" class="headerlink" title="2.频数表和列联表"></a>2.频数表和列联表</h1><p>本节中的数据来自vcd包中的Arthritis数据集。这份数据来自Kock &amp; Edward （1988） ，表示了一项风湿性关节炎新疗法的双盲临床实验的结果。前几个观测是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library(vcd)</span><br><span class="line">head(Arthritis)</span><br></pre></td></tr></table></figure>
<p><img src="/posts/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-972fc849bd835e7a447f3d9ae9860a6f_720w.jpg" alt="img"></p>
<p>治疗情况（安慰剂治疗、用药治疗）、性别（男性、女性）和改善情况（无改善、一定程度的改善、显著改善）均为类别型因子。</p>
<h2 id="2-1-生成频数表"><a href="#2-1-生成频数表" class="headerlink" title="2.1 生成频数表"></a>2.1 生成频数表</h2><p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-6f00e070172c5d851f8495984c366532_720w.jpg" alt="img"></p>
<h3 id="2-1-1-一维列联表"><a href="#2-1-1-一维列联表" class="headerlink" title="2.1.1 一维列联表"></a>2.1.1 一维列联表</h3><p>可以使用table()函数生成简单的频数统计表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mytable &lt;- with(Arthritis,table(Improved))</span><br><span class="line">mytable</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-eabe2646cde6814b487b071eebb2f281_720w.jpg" alt="img"></p>
<p>可以用prop.table()将这些频数转化为比例值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.table(mytable)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-1f6818def8bbcfe0bd5c3031c902257d_720w.jpg" alt="img"></p>
<h3 id="2-1-2-二维列联表"><a href="#2-1-2-二维列联表" class="headerlink" title="2.1.2 二维列联表"></a>2.1.2 二维列联表</h3><p>对于二维列联表，table()函数的使用格式为：</p>
<p>mytable &lt;- table(A, B)</p>
<p>其中的A是行变量，B是列变量。除此之外，xtabs()函数还可使用公式风格的输入创建列联表，格式为：</p>
<p>mytable &lt;- xtabs(~ A + B, data=mydata)</p>
<p>其中的mydata是一个矩阵或数据框。总的来说，要进行交叉分类的变量应出现在公式的右侧 （即~符号的右方），以+作为分隔符。若某个变量写在公式的左侧，则其为一个频数向量（在数据已经被表格化时很有用） 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mytable &lt;- xtabs(~Treatment+Improved,data&#x3D;Arthritis)</span><br><span class="line">mytable</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-56bd9cc92a366a59f757ecf77cd84312_720w.jpg" alt="img"></p>
<p>可以使用margin.table()和prop.table()函数分别生成边际频数和比例。行和与行比例可以这样计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margin.table(mytable,1)</span><br><span class="line">prop.table(mytable,1)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-9326520883031626c2a575be5a2e8090_720w.jpg" alt="img"></p>
<p>下标1指代table()语句中的第一个变量。观察表格可以发现，与接受安慰剂的个体中有显著改善的16%相比，接受治疗的个体中的51%的个体病情有了显著的改善。</p>
<p>列和与列比例可以这样计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margin.table(mytable,2)</span><br><span class="line">prop.table(mytable,2)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-57aef697a03f4b4d62e0e187961ce011_720w.jpg" alt="img"></p>
<p>这里的下标2指代table()语句中的第二个变量。</p>
<p>各单元格所占比例可用如下语句获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.table(mytable)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-68e40ba2b2c4c7c70091647b8a8517f1_720w.jpg" alt="img"></p>
<p>可以使用addmargins()函数为这些表格添加边际和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addmargins(mytable)</span><br><span class="line">addmargins(prop.table(mytable))</span><br><span class="line"># 仅添加了各行和各列的和</span><br><span class="line">addmargins(prop.table(mytable,1),2)</span><br><span class="line">addmargins(prop.table(mytable,2),1)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-f4f4ee9f11ce0614ee839d46e00f8e76_720w.jpg" alt="img"></p>
<p>使用gmodels包中的CrossTable()函数是创建二维列联表的第三种方法。CrossTable()函数仿照SAS中PROC FREQ或SPSS中CROSSTABS的形式生成二维列联表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library(gmodels)</span><br><span class="line">CrossTable(Arthritis$Treatment,Arthritis$Improved)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-944c6dfd0b270d47d69c62eca2881e59_720w.jpg" alt="img"></p>
<h3 id="2-1-3-多维列联表"><a href="#2-1-3-多维列联表" class="headerlink" title="2.1.3 多维列联表"></a>2.1.3 多维列联表</h3><p>table() 和 xtabs() 都 可 以 基 于 三 个 或 更 多 的 类 别 型 变 量 生 成 多 维 列 联 表 。margin.table()、prop.table()和addmargins()函数可以自然地推广到高于二维的情况。另外，ftable()函数可以以一种紧凑而吸引人的方式输出多维列联表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 三维列联表</span><br><span class="line">mytable &lt;- xtabs(~Treatment+Sex+Improved,data&#x3D;Arthritis)</span><br><span class="line">mytable</span><br><span class="line">ftable(mytable)</span><br><span class="line"># 边际频数</span><br><span class="line">margin.table(mytable,1)</span><br><span class="line">margin.table(mytable,2)</span><br><span class="line">margin.table(mytable,3)</span><br><span class="line">margin.table(mytable,c(1,3))</span><br><span class="line">margin.table(mytable,c(1,2))</span><br><span class="line">ftable(prop.table(mytable, c(1, 2))) </span><br><span class="line">ftable(addmargins(prop.table(mytable, c(1, 2)), 3))</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-f7fe47703252fd15da9760065638c9b1_720w.jpg" alt="img"></p>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-be904c2c25c43a6815a79a16b9c931e5_720w.jpg" alt="img"></p>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-8b0b97c90344759abdd96cc5194ec7ef_720w.jpg" alt="img"></p>
<h2 id="2-2-独立性检验"><a href="#2-2-独立性检验" class="headerlink" title="2.2 独立性检验"></a>2.2 独立性检验</h2><h3 id="2-2-1-卡方独立性检验"><a href="#2-2-1-卡方独立性检验" class="headerlink" title="2.2.1 卡方独立性检验"></a>2.2.1 卡方独立性检验</h3><p>可以使用chisq.test()函数对二维表的行变量和列变量进行卡方独立性检验。</p>
<p>这里的p值表示从总体中抽取的样本行变量与列变量是相互独立的概率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(vcd)</span><br><span class="line">mytable &lt;- xtabs(~Treatment+Improved, data&#x3D;Arthritis)</span><br><span class="line">chisq.test(mytable)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-14c7354be5c3b24d058efce40a7bf264_720w.jpg" alt="img"></p>
<p>结果中，患者接受的治疗和改善的水平看上去存在着某种关系（p&lt;0.01）(不独立)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mytable &lt;- xtabs(~Improved+Sex,data&#x3D;Arthritis)</span><br><span class="line">chisq.test(mytable)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-d5617a30cc6df7df25742c48303f9f35_720w.jpg" alt="img"></p>
<p>患者性别和改善情况之间却不存在关系（p&gt;0.05）(独立)。</p>
<h3 id="2-2-2-Fisher精确检验"><a href="#2-2-2-Fisher精确检验" class="headerlink" title="2.2.2 Fisher精确检验"></a>2.2.2 Fisher精确检验</h3><p>可以使用fisher.test()函数进行Fisher精确检验。Fisher精确检验的原假设是：边界固定的列联表中行和列是相互独立的。其调用格式为fisher.test(mytable)，其中的mytable是一个二维列联表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mytable &lt;- xtabs(~Treatment+Improved,data&#x3D;Arthritis)</span><br><span class="line">fisher.test(mytable)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-7dcdadec1b25fbd0e07ea36c5cd2f0a1_720w.jpg" alt="img"></p>
<p>结果中，患者接受的治疗和改善的水平看上去存在着某种关系（p&lt;0.01）(不独立)。</p>
<h3 id="2-2-3-Cochran-Mantel-Haenszel检验"><a href="#2-2-3-Cochran-Mantel-Haenszel检验" class="headerlink" title="2.2.3 Cochran-Mantel-Haenszel检验"></a>2.2.3 Cochran-Mantel-Haenszel检验</h3><p>mantelhaen.test()函数可用来进行Cochran-Mantel-Haenszel卡方检验，其原假设是， 两个名义变量在第三个变量的每一层中都是条件独立的。下列代码可以检验治疗情况和改善情况在性别的每一水平下是否独立。此检验假设不存在三阶交互作用（治疗情况×改善情况×性别） 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mytable &lt;- xtabs(~Treatment+Improved+Sex,data&#x3D;Arthritis)</span><br><span class="line">mantelhaen.test(mytable)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-c6167b3cd925aad769c5ef748bd96587_720w.jpg" alt="img"></p>
<p>结果表明，患者接受的治疗与得到的改善在性别的每一水平下并不独立（分性别来看，用药治疗的患者较接受安慰剂的患者有了更多的改善） 。</p>
<h2 id="2-3-相关性度量"><a href="#2-3-相关性度量" class="headerlink" title="2.3 相关性度量"></a>2.3 相关性度量</h2><h3 id="2-3-1-相关性度量指标"><a href="#2-3-1-相关性度量指标" class="headerlink" title="2.3.1 相关性度量指标"></a>2.3.1 相关性度量指标</h3><p>显著性检验评估了是否存在充分的证据以拒绝变量间相互独立的原假设。如果可以拒绝原假设，那么你的兴趣就会自然而然地转向用以衡量相关性强弱的相关性度量。vcd包中的assocstats()函数可以用来计算二维列联表的phi系数、列联系数和Cramer’s V系数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(vcd)</span><br><span class="line">mytable &lt;- xtabs(~Treatment+Improved,data&#x3D;Arthritis)</span><br><span class="line">assocstats(mytable)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-da1d9da82243a58dd56873294b5bc31f_720w.jpg" alt="img"></p>
<p>总体来说，较大的值意味着较强的相关性。</p>
<h3 id="2-3-2-相关性度量的可视化-类别型变量-马赛克图"><a href="#2-3-2-相关性度量的可视化-类别型变量-马赛克图" class="headerlink" title="2.3.2 相关性度量的可视化(类别型变量):马赛克图"></a>2.3.2 相关性度量的可视化(类别型变量):马赛克图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library(vcd)</span><br><span class="line">mosaic(~Treatment+Improved+Sex,data&#x3D;Arthritis,shade&#x3D;TRUE,legend&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-bf383ec481c0583433fc514d80beba76_720w.jpg" alt="img"></p>
<h1 id="3-相关"><a href="#3-相关" class="headerlink" title="3.相关"></a>3.相关</h1><p>相关系数可以用来描述定量变量之间的关系。相关系数的符号（±）表明关系的方向（正相关或负相关） ，其值的大小表示关系的强弱程度（完全不相关时为0，完全相关时为1） 。 本节中，我们将关注多种相关系数和相关性的显著性检验。我们将使用R基础安装中的state.x77数据集，它提供了美国50个州在1977年的人口、收入、文盲率、预期寿命、谋杀率和高中毕业率数据。数据集中还收录了气温和土地面积数据，但为了节约空间，这里将其丢弃。你可以使用help(state.x77)了解数据集的更多信息。除了基础安装以外，我们还将使用psych和ggm包。</p>
<h2 id="3-1-相关的类型"><a href="#3-1-相关的类型" class="headerlink" title="3.1 相关的类型"></a>3.1 相关的类型</h2><p>R可以计算多种相关系数，包括Pearson相关系数、Spearman相关系数、Kendall相关系数、偏相关系数、多分格（polychoric）相关系数和多系列（polyserial）相关系数。</p>
<h3 id="3-1-1-Pearson、Spearman和Kendall相关"><a href="#3-1-1-Pearson、Spearman和Kendall相关" class="headerlink" title="3.1.1 Pearson、Spearman和Kendall相关"></a>3.1.1 Pearson、Spearman和Kendall相关</h3><p>Pearson积差相关系数衡量了两个定量变量之间的线性相关程度。Spearman等级相关系数则衡量分级定序变量之间的相关程度。Kendall’sTau相关系数也是一种非参数的等级相关度量。cor()函数可以计算这三种相关系数，而cov()函数可用来计算协方差。两个函数的参数有很多，其中与相关系数的计算有关的参数可以简化为：</p>
<p>cor(x, use= , method= )</p>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-ed29b85654228302f4b8881f00dde68f_720w.jpg" alt="img"></p>
<p>默认参数为use=”everything”和method=”pearson”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">states &lt;- state.x77[,1:6]</span><br><span class="line">cov(states)</span><br><span class="line">cor(states)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-e4ed2232587b65753a8e369b7ef88317_720w.jpg" alt="img"></p>
<p>我们可以看到收入和高中毕业率之间存在很强的正相关，而文盲率和预期寿命之间存在很强的负相关。</p>
<p>在默认情况下得到的结果是一个方阵（所有变量之间两两计算相关） 。当你对某一组变量与另外一组变量之间的关系感兴趣时,你同样可以计算非方形的相关矩阵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- states[,c(&quot;Population&quot;, &quot;Income&quot;, &quot;Illiteracy&quot;, &quot;HS Grad&quot;)] </span><br><span class="line">y &lt;- states[,c(&quot;Life Exp&quot;, &quot;Murder&quot;)]  </span><br><span class="line">cor(x,y)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-020367797dcb742a83ce3e24b2ca0f35_720w.jpg" alt="img"></p>
<p><strong>注意，上述结果并未指明相关系数是否显著不为0（即，根据样本数据是否有足够的证据得出总体相关系数不为0的结论）。由于这个原因，你需要对相关系数进行显著性检验。</strong></p>
<h3 id="3-1-2-偏相关"><a href="#3-1-2-偏相关" class="headerlink" title="3.1.2 偏相关"></a>3.1.2 偏相关</h3><p>偏相关是指在控制一个或多个定量变量时，另外两个定量变量之间的相互关系。你可以使用ggm包中的pcor()函数计算偏相关系数。函数调用格式为：</p>
<p>pcor(u, S)</p>
<p>其中的u是一个数值向量，前两个数值表示要计算相关系数的变量下标，其余的数值为条件变量（即要排除影响的变量）的下标。S为变量的协方差阵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(ggm)</span><br><span class="line">colnames(states)</span><br><span class="line">pcor(c(1,5,2,3,6),cov(states))</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-62da63dd940bc0f83a6f33a296481ecf_720w.jpg" alt="img"></p>
<p>在控制了收入、文盲率和高中毕业率的影响时，人口和谋杀率之间的相关系数为0.346。偏相关系数常用于社会科学的研究中。</p>
<h2 id="3-2-相关性显著性检验"><a href="#3-2-相关性显著性检验" class="headerlink" title="3.2 相关性显著性检验"></a>3.2 相关性显著性检验</h2><p>在计算好相关系数以后， 如何对它们进行统计显著性检验呢？常用的原假设为变量间不相关（即总体的相关系数为0）。</p>
<p>(1) 可以使用cor.test()函数对单个的Pearson、Spearman和Kendall相关系数进行检验。</p>
<p>简化后的使用格式为：</p>
<p>cor.test(x, y, alternative = , method = )</p>
<p>其中的x和y为要检验相关性的变量，alternative则用来指定进行双侧检验或单侧检验（取值为”two.side”、”less”或”greater”），而method用以指定要计算的相关类型（”pearson”、”kendall” 或 “spearman” ） 。 当 研 究 的 假 设 为 总 体 的 相 关 系 数 小 于 0 时 ， 请 使 用alternative=”less” 。 在 研 究 的 假 设 为 总 体 的相关系 数 大 于 0 时 ， 应 使 用alternative=”greater”。在默认情况下，假设为alternative=”two.side”（总体相关系数不等于0） 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cor.test(states[,3],states[,5])</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-3da029401fc1c12fc43a78d14f466543_720w.jpg" alt="img"></p>
<p>这段代码检验了预期寿命和谋杀率的Pearson相关系数为0的原假设。假设总体的相关度为0，则预计在一千万次中只会有少于一次的机会见到0.703这样大的样本相关度（即p=1.258e–08） 。由于这种情况几乎不可能发生，所以你可以拒绝原假设，从而支持了要研究的猜想，即预期寿命和谋杀率之间的总体相关度不为0。</p>
<p>(2) 通过corr.test计算相关矩阵并进行显著性检验:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library(psych)</span><br><span class="line">corr.test(states,use&#x3D;&quot;complete&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-8092025a9c4f220a10b29b8553e4e025_720w.jpg" alt="img"></p>
<p>参数use=的取值可为”pairwise”或”complete”（分别表示对缺失值执行成对删除或行删除）。参数method=的取值可为”pearson”（默认值）、”spearman”或”kendall”。这里可以看到，人口数量和高中毕业率的相关系数（–0.10）并不显著地不为0（p=0.5） 。</p>
<h2 id="3-3-相关系数的可视化"><a href="#3-3-相关系数的可视化" class="headerlink" title="3.3 相关系数的可视化"></a>3.3 相关系数的可视化</h2><h3 id="3-3-1-散点图"><a href="#3-3-1-散点图" class="headerlink" title="3.3.1 散点图"></a>3.3.1 散点图</h3><p>(1) 添加了最佳拟合曲线的散点图</p>
<p>abline()函数用来添加最佳拟合的线性直线， 而lowess()函数则用来添加一条平滑曲线。 该平滑曲线拟合是一种基于局部加权多项式回归的非参数方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">attach(mtcars)  </span><br><span class="line">plot(wt, mpg, </span><br><span class="line">     main&#x3D;&quot;Basic Scatter plot of MPG vs. Weight&quot;, </span><br><span class="line">     xlab&#x3D;&quot;Car Weight (lbs&#x2F;1000)&quot;, </span><br><span class="line">     ylab&#x3D;&quot;Miles Per Gallon &quot;, pch&#x3D;19) </span><br><span class="line">abline(lm(mpg~wt), col&#x3D;&quot;red&quot;, lwd&#x3D;2, lty&#x3D;1) </span><br><span class="line">lines(lowess(wt,mpg), col&#x3D;&quot;blue&quot;, lwd&#x3D;2, lty&#x3D;2)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-785d6b790ae8c195748540284bcc6e98_720w.jpg" alt="img"></p>
<p>(2) car包中的scatterplot()函数增强了散点图的许多功能</p>
<p>此处，scatterplot()函数用来绘制四缸、六缸和八缸汽车每加仑英里数对车重的图形。表达式mpg ~ wt | cyl表示按条件绘图（即按cyl的水平分别绘制mpg和wt的关系图）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">library(car)  </span><br><span class="line">scatterplot(mpg ~ wt | cyl, data&#x3D;mtcars, lwd&#x3D;2, span&#x3D;0.75, </span><br><span class="line">            main&#x3D;&quot;Scatter Plot of MPG vs. Weight by # Cylinders&quot;, </span><br><span class="line">            xlab&#x3D;&quot;Weight of Car (lbs&#x2F;1000)&quot;, </span><br><span class="line">            ylab&#x3D;&quot;Miles Per Gallon&quot;, </span><br><span class="line">            legend.plot&#x3D;TRUE, </span><br><span class="line">            id.method&#x3D;&quot;identify&quot;, </span><br><span class="line">            #labels&#x3D;row.names(mtcars), </span><br><span class="line">            boxplots&#x3D;&quot;xy&quot; </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-eb708d7f4869fb0c84b1d2b201f4fc6a_720w.jpg" alt="img"></p>
<p>(3) 散点图矩阵</p>
<p>pairs()函数可以创建基础的散点图矩阵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pairs(~mpg+disp+drat+wt, data&#x3D;mtcars, </span><br><span class="line">      main&#x3D;&quot;Basic Scatter Plot Matrix&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-9548b951880161b515b96076c87cfe63_720w.jpg" alt="img"></p>
<p>car包中的scatterplotMatrix()函数也可以生成散点图矩阵:</p>
<ul>
<li>以某个因子为条件绘制散点图矩阵；</li>
<li>包含线性和平滑拟合曲线；</li>
<li>在主对角线放置箱线图、密度图或者直方图；</li>
<li>在各单元格的边界添加轴须图。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(car)  </span><br><span class="line">scatterplotMatrix(~ mpg + disp + drat + wt, data&#x3D;mtcars, </span><br><span class="line">                  spread&#x3D;FALSE, smoother.args&#x3D;list(lty&#x3D;2), </span><br><span class="line">                  main&#x3D;&quot;Scatter Plot Matrix via car Package&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-27d029d69a1fe74927775a140eed4cc9_720w.jpg" alt="img"></p>
<p>(4) 高密度散点图</p>
<p>当数据点重叠很严重时，用散点图来观察变量关系就显得“力不从心”了。</p>
<p>smoothScatter()函数可利用核密度估计生成用颜色密度来表示点分布的散点图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set.seed(1234) </span><br><span class="line">n &lt;- 10000 </span><br><span class="line">c1 &lt;- matrix(rnorm(n, mean&#x3D;0, sd&#x3D;.5), ncol&#x3D;2) </span><br><span class="line">c2 &lt;- matrix(rnorm(n, mean&#x3D;3, sd&#x3D;2), ncol&#x3D;2) </span><br><span class="line">mydata &lt;- rbind(c1, c2) </span><br><span class="line">mydata &lt;- as.data.frame(mydata) </span><br><span class="line">names(mydata) &lt;- c(&quot;x&quot;, &quot;y&quot;) </span><br><span class="line">with(mydata,smoothScatter(x,y,main&#x3D;&quot;Scatter Plot Colored by Smoothed Densities&quot;))</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-7d4a0d5aaed85d28b8b5334118266439_720w.jpg" alt="img"></p>
<p>hexbin包中的hexbin()函数将二元变量的封箱放到六边形单元格中（图形比名称更直观） 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(hexbin)</span><br><span class="line">with(mydata,&#123;bin &lt;- hexbin(x,y,xbins&#x3D;50)</span><br><span class="line">plot(bin,main &#x3D; &quot;Hexagonal Binning with 10,000 Observations&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-7c26291c28d5db5d9c51c43ed8b2cf7c_720w.jpg" alt="img"></p>
<p>(5) 三维散点图</p>
<p>散点图和散点图矩阵展示的都是二元变量关系。 倘若你想一次对三个定量变量的交互关系进行可视化呢？</p>
<p>假使你对汽车英里数、车重和排量间的关系感兴趣，可用scatterplot3d包中的scatterplot3d()函数来绘制它们的关系。格式如下：</p>
<p>scatterplot3d(x, y, z)</p>
<p>x被绘制在水平轴上，y被绘制在竖直轴上，z被绘制在透视轴上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">library(scatterplot3d)  </span><br><span class="line">attach(mtcars) </span><br><span class="line">scatterplot3d(wt, disp, mpg, </span><br><span class="line">    main&#x3D;&quot;Basic 3D Scatter Plot&quot;)</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">satterplot3d()函数提供了许多选项，包括设置图形符号、轴、颜色、线条、网格线、突出显示和角度等功能。         </span><br><span class="line">&#96;&#96;&#96;&#123;r&#125;</span><br><span class="line">library(scatterplot3d) </span><br><span class="line">attach(mtcars)  </span><br><span class="line">scatterplot3d(wt, disp, mpg, </span><br><span class="line">              pch&#x3D;16, </span><br><span class="line">              highlight.3d&#x3D;TRUE, </span><br><span class="line">              type&#x3D;&quot;h&quot;, </span><br><span class="line">              main&#x3D;&quot;3D Scatter Plot with Vertical Lines&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-cd861dfd961bb7e1d8bdc736bb6cf638_720w.jpg" alt="img"></p>
<p>我们在刚才那幅图上添加一个回归面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">library(scatterplot3d)  </span><br><span class="line">attach(mtcars) </span><br><span class="line">s3d &lt;-scatterplot3d(wt, disp, mpg, </span><br><span class="line">      pch&#x3D;16, </span><br><span class="line">      highlight.3d&#x3D;TRUE, </span><br><span class="line">      type&#x3D;&quot;h&quot;, </span><br><span class="line">      main&#x3D;&quot;3D Scatter Plot with Vertical Lines and Regression Plane&quot;) </span><br><span class="line">fit &lt;- lm(mpg ~ wt+disp) </span><br><span class="line">s3d$plane3d(fit)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-f97a3592e3295ced265e053acb5155e3_720w.jpg" alt="img"></p>
<p>(6) 气泡图</p>
<p>先创建一个二维散点图， 然后用点的大小来代表第三个变量的值。这便是气泡图（bubbleplot）。你可用symbols()函数来创建气泡图。该函数可以在指定的(x,y)坐标上绘制圆圈图、方形图、星形图、温度计图和箱线图。以绘制圆圈图为例： symbols(x, y, circle=radius) 其中x、y和radius是需要设定的向量，分别表示x、y坐标和圆圈半径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">attach(mtcars)  </span><br><span class="line">r &lt;- sqrt(disp&#x2F;pi) </span><br><span class="line">symbols(wt, mpg, circle&#x3D;r, inches&#x3D;0.30, </span><br><span class="line">        fg&#x3D;&quot;white&quot;, bg&#x3D;&quot;lightblue&quot;, </span><br><span class="line">        main&#x3D;&quot;Bubble Plot with point size proportional to displacement&quot;, </span><br><span class="line">        ylab&#x3D;&quot;Miles Per Gallon&quot;, </span><br><span class="line">        xlab&#x3D;&quot;Weight of Car (lbs&#x2F;1000)&quot;) </span><br><span class="line"># text(wt, mpg, rownames(mtcars), cex&#x3D;0.6) </span><br><span class="line">detach(mtcars)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-d9d1490084558962c6499afb25bdc0c3_720w.jpg" alt="img"></p>
<p>一般来说，统计人员使用R时都倾向于避免用气泡图，原因和避免使用饼图一样：相比对长度的判断，人们对体积/面积的判断通常更困难。但是气泡图在商业应用中非常受欢迎。</p>
<h3 id="3-3-2-折线图"><a href="#3-3-2-折线图" class="headerlink" title="3.3.2 折线图"></a>3.3.2 折线图</h3><p>如果将散点图上的点从左往右连接起来，就会得到一个折线图。</p>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-04bce0238cce2474611f2f4f7e0e25e6_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">opar &lt;- par(no.readonly&#x3D;TRUE) </span><br><span class="line">par(mfrow&#x3D;c(1,2))  </span><br><span class="line">t1 &lt;- subset(Orange, Tree&#x3D;&#x3D;1) </span><br><span class="line">plot(t1$age, t1$circumference, </span><br><span class="line">     xlab&#x3D;&quot;Age (days)&quot;, </span><br><span class="line">     ylab&#x3D;&quot;Circumference (mm)&quot;, </span><br><span class="line">     main&#x3D;&quot;Orange Tree 1 Growth&quot;) </span><br><span class="line">plot(t1$age, t1$circumference, </span><br><span class="line">     xlab&#x3D;&quot;Age (days)&quot;, </span><br><span class="line">     ylab&#x3D;&quot;Circumference (mm)&quot;, </span><br><span class="line">     main&#x3D;&quot;Orange Tree 1 Growth&quot;, </span><br><span class="line">     type&#x3D;&quot;b&quot;) </span><br><span class="line">par(opar)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-e0c28fdb60f1a6f2c7e609f0fa479c4c_720w.jpg" alt="img"></p>
<h3 id="3-3-3-相关图"><a href="#3-3-3-相关图" class="headerlink" title="3.3.3 相关图"></a>3.3.3 相关图</h3><p>利用corrgram包中的corrgram()函数，你可以用图形的方式展示该相关系数矩阵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(corrgram)  </span><br><span class="line">corrgram(mtcars, order&#x3D;TRUE, lower.panel&#x3D;panel.shade, </span><br><span class="line">         upper.panel&#x3D;panel.pie, text.panel&#x3D;panel.txt, </span><br><span class="line">         main&#x3D;&quot;Corrgram of mtcars intercorrelations&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-322d850317327893382beb102ef4feba_720w.jpg" alt="img"></p>
<p>我们先从下三角单元格（在主对角线下方的单元格）开始解释这幅图形。默认地，蓝色和从左下指向右上的斜杠表示单元格中的两个变量呈正相关。反过来，红色和从左上指向右下的斜杠表示变量呈负相关。色彩越深，饱和度越高，说明变量相关性越大。相关性接近于0的单元格基本无色。上三角单元格用饼图展示了相同的信息。颜色的功能同上，但相关性大小由被填充的饼图块的大小来展示。 正相关性将从12点钟处开始顺时针填充饼图， 而负相关性则逆时针方向填充饼图。</p>
<p>corrgram()函数的格式如下：</p>
<p>corrgram(x, order=, panel=, text.panel=, diag.panel=)</p>
<p>其中，x是一行一个观测的数据框。当order=TRUE时，相关矩阵将使用主成分分析法对变量重排序，这将使得二元变量的关系模式更为明显。选项panel设定非对角线面板使用的元素类型。你可以通过选项lower.panel和upper.panel来分别设置主对角线下方和上方的元素类型。而text.panel和diag.panel选项控制着主对角线元素类型。</p>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-62268d5df6923cd36f5fd75a44c4f801_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">library(corrgram)  </span><br><span class="line">corrgram(mtcars, order&#x3D;TRUE, lower.panel&#x3D;panel.ellipse, </span><br><span class="line">         upper.panel&#x3D;panel.pts, text.panel&#x3D;panel.txt, </span><br><span class="line">         diag.panel&#x3D;panel.minmax, </span><br><span class="line">         main&#x3D;&quot;Corrgram of mtcars data using scatter plots </span><br><span class="line">               and ellipses&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-87b3236d14ece13573241bf810ee619b_720w.jpg" alt="img"></p>
<p>最后一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library(corrgram)  </span><br><span class="line">corrgram(mtcars, lower.panel&#x3D;panel.shade, </span><br><span class="line">         upper.panel&#x3D;NULL, text.panel&#x3D;panel.txt, </span><br><span class="line">         main&#x3D;&quot;Car Mileage Data (unsorted)&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-8f348bc44894ede15fcd912809f0d70d_720w.jpg" alt="img"></p>
<h3 id="3-3-4-马赛克图"><a href="#3-3-4-马赛克图" class="headerlink" title="3.3.4 马赛克图"></a>3.3.4 马赛克图</h3><p>vcd包中的mosaic()函数可以绘制马赛克图。 （R基础安装中的mosaicplot()也可绘制马赛克图，但我还是推荐vcd包，因为它具有更多扩展功能。）以基础安装中的Titanic数据集为例，它包含存活或者死亡的乘客数、乘客的船舱等级（一等、二等、三等和船员） 、性别（男性、女性） ，以及年龄层（儿童、成人）。这是一个被充分研究过的数据集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library(vcd) </span><br><span class="line">mosaic(~Class+Sex+Age+Survived, data&#x3D;Titanic, shade&#x3D;TRUE, legend&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-9aa752871ba075ea62b9f3409b5af814_720w.jpg" alt="img"></p>
<p>在本例中，蓝色阴影表明，在假定生存率与船舱等级、性别和年龄层无关的条件下，该类别下的生存率通常超过预期值。红色阴影则含义相反。</p>
<p>赛克图隐含着大量的数据信息。例如：(1) 从船员到头等舱，存活率陡然提高；(2)大部分孩子都处在三等舱和二等舱中；(3)在头等舱中的大部分女性都存活了下来，而三等舱仅有一半女性存活；(4) 船员中女性很少，导致该组的Survived标签重叠（图底部的No和Yes） 。</p>
<h1 id="4-t检验"><a href="#4-t检验" class="headerlink" title="4.t检验"></a>4.t检验</h1><h2 id="4-1-独立样本的-t-检验"><a href="#4-1-独立样本的-t-检验" class="headerlink" title="4.1 独立样本的 t 检验"></a>4.1 独立样本的 t 检验</h2><p>如果你在美国的南方犯罪，是否更有可能被判监禁？我们比较的对象是南方和非南方各州，因变量为监禁的概率。一个针对两组的独立样本t检验<strong>可以用于检验两个总体的均值相等的假设</strong>。这里假设两组数据是独立的，并且是从正态总体中抽得。检验的调用格式为：</p>
<p>t.test(y ~ x, data)</p>
<p>其中的y是一个数值型变量，x是一个二分变量。调用格式或为：</p>
<p>t.test(y1, y2)</p>
<p>其中的y1和y2为数值型向量（即各组的结果变量） 。可选参数data的取值为一个包含了这些变量的矩阵或数据框。与其他多数统计软件不同的是，这里的t检验默认假定方差不相等，并使用Welsh的修正自由度。你可以添加一个参数var.equal=TRUE以假定方差相等，并使用合并方差估计。默认的备择假设是双侧的（即均值不相等，但大小的方向不确定）。你可以添加一个参数alternative=”less”或alternative=”greater”来进行有方向的检验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(MASS)</span><br><span class="line">head(UScrime)</span><br><span class="line">t.test(Prob~So,data&#x3D;UScrime)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-fb6bd99acfdc234f1389ba509da7de81_720w.jpg" alt="img"></p>
<p>你可以拒绝南方各州和非南方各州拥有相同监禁概率的假设（p&lt;0.001） 。</p>
<h2 id="4-2-非独立样本t检验"><a href="#4-2-非独立样本t检验" class="headerlink" title="4.2 非独立样本t检验"></a>4.2 非独立样本t检验</h2><p>再举个例子，你可能会问：较年轻（14~24岁）男性的失业率是否比年长（35~39岁）男性的失业率更高？在这种情况下，这两组数据并不独立。你不能说亚拉巴马州的年轻男性和年长男性的失业率之间没有关系。</p>
<p><strong>非独立样本的t检验假定组间的差异呈正态分布</strong>。对于本例，检验的调用格式为：</p>
<p>t.test(y1, y2, paired=TRUE)</p>
<p>其中的y1和y2为两个非独立组的数值向量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library(MASS)</span><br><span class="line">sapply(UScrime[c(&quot;U1&quot;,&quot;U2&quot;)], function(x)(c(mean(x),sd(x))))</span><br><span class="line">with(UScrime,t.test(U1,U2,paired&#x3D;TRUE))</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-047e0d929a945486decafe20fb4e0455_720w.jpg" alt="img"></p>
<p>差异的均值（61.5）足够大，可以保证拒绝年长和年轻男性的平均失业率相同的假设。年轻男性的失业率更高。事实上，若总体均值相等，获取一个差异如此大的样本的概率小于0.000 000 000 000 000 22（即2.2e–16） 。</p>
<h1 id="5-组间差异的非参数检验"><a href="#5-组间差异的非参数检验" class="headerlink" title="5.组间差异的非参数检验"></a>5.组间差异的非参数检验</h1><p>如果数据无法满足t检验或ANOVA的参数假设，若结果变量在本质上就严重偏倚或呈现有序关系，可以转而使用非参数方法。</p>
<h2 id="5-1-两组的比较"><a href="#5-1-两组的比较" class="headerlink" title="5.1 两组的比较"></a>5.1 两组的比较</h2><p>若两组数据独立，可以使用Wilcoxon秩和检验（更广为人知的名字是Mann-WhitneyU检验）来评估观测是否是从相同的概率分布中抽得的（即，在一个总体中获得更高得分的概率是否比另一个总体要大） 。调用格式为：</p>
<p>wilcox.test(y ~ x, data)</p>
<p>其中的y是数值型变量，而x是一个二分变量。调用格式或为：</p>
<p>wilcox.test(y1, y2)</p>
<p>其中的y1和y2为各组的结果变量。可选参数data的取值为一个包含了这些变量的矩阵或数据框。默认进行一个双侧检验。你可以添加参数exact来进行精确检验，指定alternative=”less”或alternative=”greater”进行有方向的检验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with(UScrime, by(Prob, So, median)) </span><br><span class="line">with(UScrime,wilcox.test(Prob~So,data&#x3D;UScrime))</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-613a74ae52943f25e2f1686a1eacfe7b_720w.jpg" alt="img"></p>
<p>你可以再次拒绝南方各州和非南方各州监禁率相同的假设（p&lt;0.001） 。</p>
<p>Wilcoxon符号秩检验是非独立样本t检验的一种非参数替代方法。它适用于两组成对数据和无法保证正态性假设的情境。调用格式与Mann-WhitneyU检验完全相同，不过还可以添加参数paired=TRUE。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sapply(UScrime[c(&quot;U1&quot;,&quot;U2&quot;)], median)</span><br><span class="line">with(UScrime,wilcox.test(U1,U2,paired &#x3D; TRUE))</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-93154106af0a60e4a3ec71d4a8785dca_720w.jpg" alt="img"></p>
<p>你再次得到了与配对t检验相同的结论。</p>
<p>在本例中，含参的t检验和与其作用相同的非参数检验得到了相同的结论。当t检验的假设合理时，参数检验的功效更强（更容易发现存在的差异）。而非参数检验在假设非常不合理时（如<strong>对于等级有序数据</strong>）更适用。</p>
<h2 id="5-2-多于两组的比较"><a href="#5-2-多于两组的比较" class="headerlink" title="5.2 多于两组的比较"></a>5.2 多于两组的比较</h2><p>考虑state.x77数据集。它包含了美国各州的人口、收入、文盲率、预期寿命、谋杀率和高中毕业率数据。如果你想比较美国四个地区（东北部、南部、中北部和西部）的文盲率， 应该怎么做呢？这称为单向设计 （one-waydesign），我们可以使用参数或非参数的方法来解决这个问题。如果无法满足ANOVA设计的假设，那么可以使用非参数方法来评估组间的差异。如果各组独立，则Kruskal-Wallis检验将是一种实用的方法。如果各组不独立（如重复测量设计或随机区组设计），那么Friedman检验会更合适。</p>
<p>Kruskal-Wallis检验的调用格式为：</p>
<p>kruskal.test(y ~ A, data)</p>
<p>其中的y是一个数值型结果变量，A是一个拥有两个或更多水平的分组变量（grouping variable）。（若有两个水平，则它与Mann-Whitney U检验等价。 ）</p>
<p>而Friedman检验的调用格式为：</p>
<p>friedman.test(y ~ A | B, data)</p>
<p>其中的y是数值型结果变量，A是一个分组变量，而B是一个用以认定匹配观测的区组变量（blockingvariable）。在以上两例中，data皆为可选参数，它指定了包含这些变量的矩阵或数据框。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">states &lt;- data.frame(state.region, state.x77) </span><br><span class="line">kruskal.test(Illiteracy ~ state.region, data&#x3D;states)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-d4e51ee79856f83cc3814cd589f68244_720w.jpg" alt="img"></p>
<p>显著性检验的结果意味着美国四个地区的文盲率各不相同（p&lt;0.001） 。</p>
<p>虽然你可以拒绝不存在差异的原假设， 但这个检验并没有告诉你哪些地区显著地与其他地区不同。要回答这个问题，你可以使用Wilcoxon检验每次比较两组数据。一种更为优雅的方法是在控制犯第一类错误的概率（发现一个事实上并不存在的差异的概率）的前提下，执行可以同步进行的多组比较， 这样可以直接完成所有组之间的成对比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"># Nonparametric pairwise multiple comparisons using the Wilcoxon Signed Rank Test</span><br><span class="line"># Probability values are adjusted using the p.adjust function</span><br><span class="line">wmc &lt;- function(formula, data, exact&#x3D;FALSE, sort&#x3D;TRUE, method&#x3D;&quot;holm&quot;)&#123;</span><br><span class="line"></span><br><span class="line">  # setup</span><br><span class="line">  df &lt;- model.frame(formula, data)</span><br><span class="line">  y &lt;- df[[1]]</span><br><span class="line">  x &lt;- as.factor(df[[2]])</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  # reorder levels of x by median y</span><br><span class="line">  if(sort)&#123;</span><br><span class="line">    medians &lt;- aggregate(y, by&#x3D;list(x), FUN&#x3D;median)[2]</span><br><span class="line">    index &lt;- order(medians)</span><br><span class="line">    x &lt;- factor(x, levels(x)[index])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  groups &lt;- levels(x)</span><br><span class="line">  k &lt;- length(groups)</span><br><span class="line">  </span><br><span class="line">  # summary statistics</span><br><span class="line">  stats &lt;- function(z)(c(N &#x3D; length(z), Median &#x3D; median(z), MAD &#x3D; mad(z)))</span><br><span class="line">  sumstats &lt;- t(aggregate(y, by&#x3D;list(x), FUN&#x3D;stats)[2])</span><br><span class="line">  rownames(sumstats) &lt;- c(&quot;n&quot;, &quot;median&quot;, &quot;mad&quot;)</span><br><span class="line">  colnames(sumstats) &lt;- groups</span><br><span class="line">  cat(&quot;Descriptive Statistics\n\n&quot;)</span><br><span class="line">  print(sumstats)</span><br><span class="line">  </span><br><span class="line">  # multiple comparisons</span><br><span class="line">  mc &lt;- data.frame(Group.1&#x3D;character(0), </span><br><span class="line">                   Group.2&#x3D;character(0), </span><br><span class="line">                   W&#x3D;numeric(0),</span><br><span class="line">                   p.unadj&#x3D;numeric(0), </span><br><span class="line">                   p&#x3D;numeric(0),</span><br><span class="line">                   stars&#x3D;character(0),</span><br><span class="line">                   stringsAsFactors&#x3D;FALSE)</span><br><span class="line">  </span><br><span class="line">  # perform Wilcoxon test</span><br><span class="line">  row &lt;- 0</span><br><span class="line">  for(i in 1:k)&#123;</span><br><span class="line">    for(j in 1:k)&#123;</span><br><span class="line">      if (j &gt; i)&#123;</span><br><span class="line">        row &lt;- row + 1</span><br><span class="line">        y1 &lt;- y[x&#x3D;&#x3D;groups[i]]</span><br><span class="line">        y2 &lt;- y[x&#x3D;&#x3D;groups[j]] </span><br><span class="line">        test &lt;- wilcox.test(y1, y2, exact&#x3D;exact)</span><br><span class="line">        mc[row,1] &lt;- groups[i]</span><br><span class="line">        mc[row,2] &lt;- groups[j]</span><br><span class="line">        mc[row,3] &lt;- test$statistic</span><br><span class="line">        mc[row,4] &lt;- test$p.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mc$p &lt;- p.adjust(mc$p.unadj, method&#x3D;method)</span><br><span class="line">  </span><br><span class="line">  # add stars</span><br><span class="line">  mc$stars &lt;- &quot; &quot;</span><br><span class="line">  mc$stars[mc$p &lt;   .1] &lt;- &quot;.&quot;</span><br><span class="line">  mc$stars[mc$p &lt;  .05] &lt;- &quot;*&quot;</span><br><span class="line">  mc$stars[mc$p &lt;  .01] &lt;- &quot;**&quot;</span><br><span class="line">  mc$stars[mc$p &lt; .001] &lt;- &quot;***&quot;</span><br><span class="line">  names(mc)[6] &lt;- &quot; &quot;</span><br><span class="line">  </span><br><span class="line">  cat(&quot;\nMultiple Comparisons (Wilcoxon Rank Sum Tests)\n&quot;)</span><br><span class="line">  cat(paste(&quot;Probability Adjustment &#x3D; &quot;, method, &quot;\n\n&quot;, sep&#x3D;&quot;&quot;))</span><br><span class="line">  print(mc[-4], right&#x3D;TRUE)</span><br><span class="line">  cat(&quot;---\nSignif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1\n&quot;)</span><br><span class="line">  return(invisible(NULL))</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wmc(Illiteracy ~ state.region, data&#x3D;states, method&#x3D;&quot;holm&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/Pic/R%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/v2-988542c2ecda1aab54a4cba442d63b7e_720w.jpg" alt="img"></p>
<p>wmc()函数首先给出了样本量、样本中位数、每组的绝对中位差。其中，西部地区（West）的文盲率最低，南部地区（South）文盲率最高。然后，函数生成了六组统计比较（南部与中北部（North Central） 、西部与东北部（Northeast）、西部与南部、中北部与东北部、中北部与南部、东北部与南部）。可以从双侧p值（p）看到，南部与其他三个区域有明显差别，但当显著性水平p＜0.05时，其他三个区域间并没有统计显著的差别。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在本次分享中，我们评述了R中用于生成统计概要和进行假设检验的函数。我们关注了样本统计量和频数表、独立性检验和类别型变量的相关性度量、定量变量的相关系数（和连带的显著性检验）以及两组或更多组定量结果变量的比较。下次分享，我们将探索一元回归和多元回归，讨论的焦点在于如何理解一个预测变量（一元回归）或多个预测变量（多元回归）与某个被预测变量或效标变量（criterion variable）之间的关系。图形将有助于诊断潜在的问题、评估和提高模型的拟合精度，并发现数据中意料之外的信息瑰宝。</p>
<blockquote>
<p>本文转载自知乎：<a href="https://zhuanlan.zhihu.com/p/181729801" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/181729801</a></p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://chenkai66.github.io/posts/17ce1303.html" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/posts/167437d7.html" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            金融量化分析基础（九）—— 如何平滑收益曲线
          
        </div>
      </a>
    
    
      <a href="/posts/7224cc4c.html" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">金融量化分析基础（八）—— 量化策略交易风险防范</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "TQy5bHTePagP10u5BBsesx61-gzGzoHsz",
    app_key: "O6UyJYxBFgMKQMjktBh4KGad",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020
        <i class="ri-heart-fill heart_icon"></i> chenk
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 每天都变得更帅的自己 强力驱动
        
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="言念君子"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-haruto"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>